package decoder

import (
	"bytes"
	"io"
	"testing"
)

func TestReadINFOChunk_Success_With_Odd_Size(t *testing.T) {
	b := []byte{
		// Artist, Creation Date, Title, Genre, Product, Comments
		0x49, 0x4e, 0x41, 0x4d, 0x0c, 0x00, 0x00, 0x00, 0x74, 0x72, 0x61, 0x63, 0x6b,
		0x20, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x00, 0x49, 0x50, 0x52, 0x44, 0x0c, 0x00, 0x00,
		0x00, 0x61, 0x6c, 0x62, 0x75, 0x6d, 0x20, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x00, 0x49,
		0x41, 0x52, 0x54, 0x08, 0x00, 0x00, 0x00, 0x61, 0x72, 0x74, 0x69, 0x73, 0x74, 0x00,
		0x00, 0x49, 0x43, 0x4d, 0x54, 0x0c, 0x00, 0x00, 0x00, 0x6d, 0x79, 0x20, 0x63, 0x6f,
		0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x00, 0x00, 0x49, 0x43, 0x52, 0x44, 0x06, 0x00, 0x00,
		0x00, 0x32, 0x30, 0x31, 0x37, 0x00, 0x00, 0x49, 0x47, 0x4e, 0x52, 0x06, 0x00, 0x00,
		0x00, 0x67, 0x65, 0x6e, 0x72, 0x65, 0x00, 0x49, 0x54, 0x52, 0x4b, 0x04, 0x00, 0x00,
		0x00, 0x34, 0x32, 0x00, 0x00, 0x69, 0x64, 0x33, 0x20, 0x8c, 0x00, 0x00, 0x00, 0x49,
		0x44, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x54, 0x41, 0x4c, 0x42, 0x00,
		0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x61, 0x6c, 0x62, 0x75, 0x6d, 0x20, 0x74, 0x69,
		0x74, 0x6c, 0x65, 0x54, 0x49, 0x54, 0x32, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00,
		0x74, 0x72, 0x61, 0x63, 0x6b, 0x20, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x54, 0x52, 0x43,
		0x4b, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x34, 0x32, 0x43, 0x4f, 0x4d, 0x4d,
		0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6d, 0x79, 0x20,
		0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x54, 0x50, 0x45, 0x31, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x61, 0x72, 0x74, 0x69, 0x73, 0x74, 0x54, 0x44, 0x52, 0x43,
		0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x32, 0x30, 0x31, 0x37, 0x54, 0x43, 0x4f,
		0x4e, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x67, 0x65, 0x6e, 0x72, 0x65,

		// Location
		0x49, 0x41, 0x52, 0x4c,
		0x04, 0x00, 0x00, 0x00,
		0x74, 0x65, 0x73, 0x74,
		// Software
		0x49, 0x53, 0x46, 0x54,
		0x04, 0x00, 0x00, 0x00,
		0x74, 0x65, 0x73, 0x74,
		// Copyright
		0x49, 0x43, 0x4f, 0x50,
		0x04, 0x00, 0x00, 0x00,
		0x74, 0x65, 0x73, 0x74,
		// Engineer
		0x49, 0x45, 0x4e, 0x47,
		0x04, 0x00, 0x00, 0x00,
		0x74, 0x65, 0x73, 0x74,
		// Source
		0x49, 0x53, 0x52, 0x43,
		0x04, 0x00, 0x00, 0x00,
		0x74, 0x65, 0x73, 0x74,
		// Subject
		0x49, 0x53, 0x42, 0x4a,
		0x04, 0x00, 0x00, 0x00,
		0x74, 0x65, 0x73, 0x74,
		// Technician
		0x49, 0x54, 0x43, 0x48,
		0x04, 0x00, 0x00, 0x00,
		0x74, 0x65, 0x73, 0x74,
		// Keywords
		0x49, 0x4b, 0x45, 0x59,
		0x04, 0x00, 0x00, 0x00,
		0x74, 0x65, 0x73, 0x74,
		// Medium (odd size - to test add extra byte)
		0x49, 0x4d, 0x45, 0x44,
		0x03, 0x00, 0x00, 0x00,
		0x74, 0x65, 0x73, 0x74,
	}

	r := bytes.NewReader(b)

	i, err := readINFOChunk(r)
	if err != nil {
		t.Errorf("Error: %s", err.Error())
	}

	if i.Artist != "artist" {
		t.Errorf("Error: did not find the correct artist. Found %s", i.Artist)
	}

	if i.CreationDate != "2017" {
		t.Errorf("Error: did not find the correct creation date. Found %s", i.CreationDate)
	}

	if i.Title != "track title" {
		t.Errorf("Error: did not find the correct title. Found %s", i.Title)
	}

	if i.Genre != "genre" {
		t.Errorf("Error: did not find the correct genre. Found %s", i.Genre)
	}

	if i.Product != "album title" {
		t.Errorf("Error: did not find the correct product. Found %s", i.Product)
	}

	if i.Comments != "my comment" {
		t.Errorf("Error: did not find the correct comments. Found %s", i.Comments)
	}

	if i.Location != "test" {
		t.Errorf("expected \"test\". received \"%s\"", i.Location)
	}

	if i.Software != "test" {
		t.Errorf("expected \"test\". received \"%s\"", i.Software)
	}

	if i.Copyright != "test" {
		t.Errorf("expected \"test\". received \"%s\"", i.Copyright)
	}

	if i.Engineer != "test" {
		t.Errorf("expected \"test\". received \"%s\"", i.Engineer)
	}

	if i.Source != "test" {
		t.Errorf("expected \"test\". received \"%s\"", i.Source)
	}

	if i.Subject != "test" {
		t.Errorf("expected \"test\". received \"%s\"", i.Subject)
	}

	if i.Technician != "test" {
		t.Errorf("expected \"test\". received \"%s\"", i.Technician)
	}

	if i.Keywords != "test" {
		t.Errorf("expected \"test\". received \"%s\"", i.Keywords)
	}

	if i.Medium != "test" {
		t.Errorf("expected \"test\". received \"%s\"", i.Medium)
	}

}

func TestReadInfoChunk_Fail_Short_Chunk_ID(t *testing.T) {
	b := []byte{
		// Location
		0x49, 0x41, 0x52,
	}

	r := bytes.NewReader(b)

	i, err := readINFOChunk(r)

	if i != nil {
		t.Error("returned info chunk is not nil")
	}

	if err == nil {
		t.Error(err.Error())
	}

	if err != io.ErrUnexpectedEOF {
		t.Errorf("expected \"Unexpected EOF\". received \"%s\"", err.Error())
	}
}

func TestReadInfoChunk_Fail_Short_Chunk_Size(t *testing.T) {
	b := []byte{
		// Location
		0x49, 0x41, 0x52, 0x4c,
		0x04, 0x00, 0x00,
	}

	r := bytes.NewReader(b)

	i, err := readINFOChunk(r)

	if i != nil {
		t.Error("returned info chunk is not nil")
	}

	if err == nil {
		t.Error(err.Error())
	}

	if err != io.ErrUnexpectedEOF {
		t.Errorf("expected \"Unexpected EOF\". received \"%s\"", err.Error())
	}
}

func TestReadInfoChunk_Fail_Short_Data(t *testing.T) {
	b := []byte{
		// Location
		0x49, 0x41, 0x52, 0x4c,
		0x04, 0x00, 0x00, 0x00,
		0x74, 0x65, 0x73,
	}

	r := bytes.NewReader(b)

	i, err := readINFOChunk(r)

	if i != nil {
		t.Error("returned info chunk is not nil")
	}

	if err == nil {
		t.Error(err.Error())
	}

	if err != io.ErrUnexpectedEOF {
		t.Errorf("expected \"Unexpected EOF\". received \"%s\"", err.Error())
	}
}
